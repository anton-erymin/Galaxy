#include "CommonConstants.h"
#include "SimulationLayout.h"

shared uint s_body_count;
shared uint s_nodes_max_count;
shared uint s_total_count;
shared float s_radius;

// Helpers must be included after declaring shared vars and layout
#include "TreeHelpers.h"
	
layout(local_size_x = 1) in;

void main()
{
	if (gl_LocalInvocationID.x == 0)
	{
		// Load to shared storage
		s_body_count = g_body_count;
		s_nodes_max_count = g_nodes_max_count;
		s_total_count = g_total_count;
		s_radius = g_radius;
		s_radius = 20.0;
		
		BBox root_box = BBox_Create(vec3(-20.0), vec3(20.0));
		ResetTree(root_box);
		
		//EnablePrintf();
		//printf("Tree reset %f!\n", s_radius);
	}
	
    int gidx = int(gl_GlobalInvocationID.x);
    
	memoryBarrierShared();
	barrier();
	
	if (gidx >= int(GetBodyCount()))
	{
		return;
	}
	
    int stride = int(gl_WorkGroupSize.x * gl_NumWorkGroups.x);
    bool next_body = true;
    
	int node, new_node, subdivided_node, subdivided_branch, subtree;
	int child_branch, old_child_branch, child_index;
	vec3 node_pos, new_node_pos, body_pos, old_body_pos;
	float current_radius;
	
    // Insert each particle assigned to this thread
	while (gidx < int(GetBodyCount()))
    {
        if (next_body)
        {
            next_body = false;
			body_pos = GetPosition(gidx).xyz;
			
            // Setup follow from the root
			node = GetRootNode();
			node_pos = GetPosition(node).xyz;
			current_radius = s_radius;
			
			child_branch = FindChildBranch(node_pos, body_pos);
        }

		child_index = GetChildIndex(node, child_branch);
	
        // Follow from root to the current available leaf
		while (IsNode(child_index))
		{
			node = child_index;
			node_pos = GetPosition(node).xyz;
			child_branch = FindChildBranch(node_pos, body_pos);
			child_index = GetChildIndex(node, child_branch);
			current_radius *= 0.5;
		}
		
        if (!IsLocked(child_index))
        {
			#if 1
            // Try to lock.
            if (TryLockChild(node, child_branch, child_index))
            {    
                if (IsNull(child_index))
                {
                    // No body here yet so just insert and thus unlock
					SetChildIndex(node, child_branch, gidx);
                }
                else
                {
 					//g_debug[1] = child_index;
					//AddNode(vec4(5.0, 5.0, 5.0, 150.0));
					
					//printf("We are here %d\n", child_index);
					
					//return;
					
                    // Child is body
					// Create new node(s) and insert the old and new body
                    // New nodes are created until both are in different childs.

					old_body_pos = GetPosition(child_index).xyz;
					subdivided_node = node;
					subdivided_branch = child_branch;
					subtree = -1;

					do
					{
						// Create new node
						
						new_node_pos = GetChildCenterPos(node_pos, child_branch, current_radius);
						current_radius *= 0.5;
						new_node = AddNode(vec4(new_node_pos, current_radius));

						// Get index of subtree
						subtree = max(subtree, new_node);

						// Link new child node to parent
						if (new_node != subtree)
						{
							SetChildIndex(node, child_branch, new_node);
						}

						// Find branches for old and new bodies in newly created node
						child_branch = FindChildBranch(new_node_pos, body_pos);
						old_child_branch = FindChildBranch(new_node_pos, old_body_pos);

						node = new_node;
						node_pos = new_node_pos;
					}
					while (child_branch == old_child_branch); // Subdivide until two bodies are in different child branches
                    
                    // Insert bodies.
                    SetChildIndex(node, old_child_branch, child_index); // Old body
					SetChildIndex(node, child_branch, gidx); // New body
					
					// Attach new subtree to tree unlocking the branch
					SetChildIndex(subdivided_node, subdivided_branch, subtree);
                }
                
				// To the next body if any.
				gidx += stride;
				next_body = true;
            } // Lock
			#endif
        }
        
        memoryBarrierBuffer();
		barrier();
    }
}
