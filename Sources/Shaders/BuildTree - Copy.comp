//#include "SceneData.h"

#define DEFINE_ROOT_CONSTANTS
#include "SimulationLayout.h"
#include "BodyHelpers.h"

layout(local_size_x = 256) in;

void main()
{
    int gidx = int(gl_GlobalInvocationID.x);
    
    if (gidx >= PARTICLES_COUNT)
    {
        return;
    }

    const vec3 root_position = vec3(0);

    if (gidx == 0)
    {
    }
    
    //memoryBarrier();
    barrier();
    
    
    
#if 0    
uvec3 gl_NumWorkGroups;
        uvec3 gl_WorkGroupSize;
        uvec3 gl_WorkGroupID;
        uvec3 gl_LocalInvocationID;
        uvec3 gl_GlobalInvocationID;
        uint  gl_LocalInvocationIndex;
#endif
		
    float current_radius = 0.0;
    int parent_idx = 0;
    int child_idx = 0;
    int child_branch = 0;
    int new_branch = 0;
    int new_node_idx = 0;
    int subtree_root = 0;
    int locked_node = 0;
    int locked_branch = 0;
    int locked_depth = 0;
    int old_idx = 0;
    int depth = 0;
    vec3 node_position, old_pos;
    Particle p;
    Node node;
    bool next_body = true;
    
    int stride = int(gl_WorkGroupSize.x * gl_NumWorkGroups.x);
    
    int body_idx = gidx;
    
    memoryBarrierBuffer();
    barrier();
    
    // Insert each particle assigned to this thread.
    while (body_idx < PARTICLES_COUNT)
    {
        if (next_body)
        {
            next_body = false;
            
            // Setup follow from the root.
            child_idx = 0;
            depth = 0;
            current_radius = ROOT_RADIUS;
            p = g_particles[body_idx];
            
            // Check if it fits to root bounding box.
            if (abs(p.position.x - root_position.x) > current_radius ||
                abs(p.position.z - root_position.z) > current_radius)
            {
                body_idx += stride;                
                next_body = true;
                continue;
            }
        }
        else
        {
            // Read again.
            child_idx = g_nodes[parent_idx].child[child_branch].x;
        }
        
        // Follow or continue follow path to the leaf.
        while (IsNode(child_idx))
        {
            parent_idx = child_idx;
            current_radius *= 0.5;
            ++depth;
            
            node = g_nodes[parent_idx];
            child_branch = FindChildBranch(node.position.xyz, p.position.xyz);
            child_idx = node.child[child_branch].x;
        }
        
        if (child_idx != NODE_LOCKED)
        {
            // Try to lock.
            if (child_idx == atomicCompSwap(
                g_nodes[parent_idx].child[child_branch].x, child_idx, NODE_LOCKED))
            {    
                if (child_idx == EMPTY_INDEX)
                {
                    // Empty node, so just insert and thus unlock.
                    g_nodes[parent_idx].child[child_branch].x = EncodeParticleIndex(body_idx);
                }
                else
                {
                    // Create new nodes and insert the old and new body.
                    // New nodes are created until both are in different childs.
                    
                    old_idx = DecodeParticleIndex(child_idx);
                    old_pos = g_particles[old_idx].position.xyz;
                    node_position = node.position.xyz;
                    locked_node = parent_idx;
                    locked_branch = child_branch;
                    locked_depth = depth;
                    
                    while (true)
                    {
                        // Get next free node index.
                        new_node_idx = int(atomicAdd(g_nodes_counter, 1u));
                        
                        // Create node.
                        Node new_node;
                        new_node.mass = 0.0;
                        new_node.depth = depth;
                        
                        for (int i = 0; i < NODE_CHILD_COUNT; ++i)
                        {
                            new_node.child[i].x = EMPTY_INDEX;
                        }
                        
                        vec3 node_offset = vec3(0.0);
                        node_offset.x = float((child_branch >> 1) & 1) * current_radius;
                        node_offset.z = float(child_branch & 1) * current_radius;
                        
                        // Map from [0; R] to [-R; R].
                        node_offset = 2 * node_offset - vec3(current_radius, 0.0, current_radius);
                        
                        node_position += node_offset;
                        
                        new_node.position.xyz = node_position;
                        
                        g_nodes[new_node_idx] = new_node;
                        
                        // Set node as child if we went further.
                        // otherwise we unlock too early.
                        if (depth > locked_depth)
                        {
                            g_nodes[parent_idx].child[child_branch].x = new_node_idx;
                        }
                        else
                        {
                            subtree_root = new_node_idx;
                        }
                        
                        parent_idx = new_node_idx;

                        // Check if both bodies fit into different childs.
                        
                        child_branch = FindChildBranch(node_position, old_pos);
                        new_branch = FindChildBranch(node_position, p.position.xyz);
                        
                        if (child_branch != new_branch)
                        {
                            // Break inserting nodes.
                            break;
                        }
                        
                        // Both bodies fit into the same child, continue inserting.
                        current_radius *= 0.5;
                        ++depth;
                    }
                    
                    // Insert bodies.
                    g_nodes[parent_idx].child[child_branch].x = child_idx;
                    g_nodes[parent_idx].child[new_branch].x = EncodeParticleIndex(body_idx);
                    // Unlock branch.
                    g_nodes[locked_node].child[locked_branch].x = subtree_root;
                }
                
                memoryBarrierBuffer();
                
                // To the next body if any.
                body_idx += stride;
                next_body = true;
            }
        }
        
        barrier();
        //memoryBarrier();
    }
#endif
}
